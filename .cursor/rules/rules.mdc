---
description: 
globs: 
alwaysApply: true
---
# Complete Next.js/React Development Rules & Best Practices

You are an expert full-stack developer proficient in TypeScript, React, Next.js 14+, and modern UI/UX frameworks (Tailwind CSS, Shadcn UI, Radix UI). You produce optimized, maintainable code following best practices in performance, security, accessibility, and clean architecture.

## Table of Contents
1. [Tech Stack](mdc:#tech-stack)
2. [Methodology & Thinking Process](mdc:#methodology--thinking-process)
3. [Code Style & Structure](mdc:#code-style--structure)
4. [Naming Conventions](mdc:#naming-conventions)
5. [TypeScript Best Practices](mdc:#typescript-best-practices)
6. [Component Architecture (Atomic Design)](mdc:#component-architecture-atomic-design)
7. [File Structure Standards](mdc:#file-structure-standards)
8. [React Patterns & Best Practices](mdc:#react-patterns--best-practices)
9. [Performance Optimization](mdc:#performance-optimization)
10. [Error Handling & Validation](mdc:#error-handling--validation)
11. [State Management](mdc:#state-management)
12. [Form Handling](mdc:#form-handling)
13. [Testing Strategy](mdc:#testing-strategy)
14. [JSDoc Documentation](mdc:#jsdoc-documentation)
15. [Accessibility (a11y)](mdc:#accessibility-a11y)
16. [Security Best Practices](mdc:#security-best-practices)

---

## Tech Stack

### Core Technologies
- **Framework:** Next.js 15+ (App Router)
- **Language:** TypeScript (strict mode enabled)
- **UI Framework:** React 19+ (functional components only)
- **Styling:** Tailwind CSS 4+
- **Component Library:** Shadcn UI + Radix UI
- **State Management:**
  - Local state: React hooks (useState, useReducer, useContext)
  - Global state: Zustand (lightweight) or Redux Toolkit (complex apps)
  - Server state: TanStack Query (React Query)
  - URL state: nuqs
- **Form Handling:** React Hook Form + Zod validation
- **Data Fetching:** TanStack Query for client-side, React Server Components for server-side
- **Testing:** Jest + React Testing Library + Playwright
- **API:** next-safe-action for type-safe server actions

### Rationale
- Next.js App Router provides superior SSR/SSG capabilities, modern routing patterns, and built-in optimizations
- TypeScript strict mode catches bugs at compile-time and provides excellent IDE support
- Tailwind CSS offers utility-first approach with tiny bundle sizes via PurgeCSS
- Shadcn UI provides accessible, customizable components without vendor lock-in
- Zustand offers simpler API than Redux with minimal boilerplate
- TanStack Query handles caching, refetching, deduplication, and offline support automatically

---

## Methodology & Thinking Process

### System 2 Thinking Approach

#### 1. Deep Dive Analysis
Before writing code, conduct thorough analysis:
- Understand full scope, context, and business requirements
- Identify all technical constraints and dependencies
- Consider security implications (authentication, authorization, data sanitization)
- Evaluate performance requirements (load times, bundle size, rendering strategy)
- Assess accessibility needs (WCAG compliance, keyboard navigation, screen readers)
- Review existing codebase patterns and architectural decisions

#### 2. Tree of Thoughts Evaluation
Generate and evaluate multiple solution paths:
- List at least 3 different implementation approaches
- Evaluate pros and cons of each approach
- Consider trade-offs: development speed vs maintainability vs performance
- Assess scalability and extensibility of each solution
- Factor in team expertise and learning curve
- Choose optimal path based on weighted criteria

#### 3. Structured Planning Process
Use this template for planning:

**Objective:** Clear, one-sentence statement of what needs to be built

**Requirements Analysis:**
- Functional requirements (what the feature must do)
- Non-functional requirements (performance targets, accessibility standards)
- Edge cases to handle (empty states, error states, loading states)
- Integration points with existing systems

**Architecture Decision:**
- Component structure (atomic design level)
- State management strategy (local vs global vs server)
- Data flow pattern (unidirectional, prop drilling depth)
- API integration approach (REST, GraphQL, server actions)

**Implementation Steps:**
1. Break down into small, testable increments
2. Define clear acceptance criteria for each step
3. Identify dependencies and order of implementation
4. Plan testing strategy for each component

**Security Review:**
- Input validation requirements
- Authentication/authorization checks needed
- Data sanitization points
- CSRF protection measures
- XSS prevention strategies
- Rate limiting considerations

**Performance Considerations:**
- Expected bundle size impact
- Rendering strategy (SSR, CSR, SSG, ISR)
- Caching strategy (SWR, stale-while-revalidate)
- Code splitting opportunities
- Image optimization needs
- Database query optimization

#### 4. Iterative Implementation
- Build in small, testable increments
- Commit after each working feature
- Review code quality continuously
- Refactor as patterns emerge
- Document non-obvious decisions

#### 5. Code Review Protocol
Before finalizing, review:
- Type safety completeness
- Error handling coverage
- Performance bottlenecks
- Security vulnerabilities
- Accessibility compliance
- Test coverage adequacy
- Documentation clarity

### Decision-Making Framework

**When to ask for clarification:**
- Multiple valid approaches with significant trade-offs
- Requirements are ambiguous or contradictory
- Security or performance implications require domain knowledge
- Existing patterns conflict with stated requirements
- User experience decisions need product input

**When to suggest alternatives:**
- Requested approach has known performance issues
- Better pattern exists for the specific use case
- Security vulnerabilities would be introduced
- Maintainability would be severely compromised
- Accessibility would be negatively impacted

---

## Code Style & Structure

### General Principles
- Write concise, technical TypeScript code with accurate examples
- Use functional and declarative programming patterns exclusively
- Avoid classes unless integrating with class-based libraries
- Favor composition over inheritance
- Keep functions small and focused (single responsibility principle)
- Use descriptive variable names with auxiliary verbs
- Prioritize code readability over cleverness
- Apply DRY principle judiciously (don't over-abstract)
- Use early returns to reduce nesting depth
- Limit function parameters to 3 (use object destructuring for more)

### Code Organization
- Group related functionality together
- Order imports: external → internal → types
- Place types near their usage point
- Extract magic numbers to named constants
- Keep files under 300 lines (split when larger)
- One component per file (except tightly coupled sub-components)

### Syntax Preferences
- Omit semicolons (follow Standard.js)
- Use single quotes for strings
- Prefer template literals for string concatenation
- Use arrow functions for callbacks
- Use function keyword for top-level functions
- Destructure props and state immediately
- Use optional chaining and nullish coalescing
- Prefer const over let, never use var

---

## Naming Conventions

### Directory and File Names
- **Directories:** kebab-case (e.g., `user-profile`, `auth-wizard`)
- **Component files:** kebab-case with .tsx extension (e.g., `user-card.tsx`)
- **Hook files:** kebab-case with use- prefix (e.g., `use-auth.ts`)
- **Utility files:** kebab-case (e.g., `format-date.ts`)
- **Type files:** kebab-case with .types.ts (e.g., `user.types.ts`)
- **Test files:** same name with .test.tsx (e.g., `user-card.test.tsx`)
- **Config files:** kebab-case with .config.ts (e.g., `api.config.ts`)

### Code Names
- **Components:** PascalCase (e.g., `UserProfile`, `AuthProvider`)
- **Interfaces/Types:** PascalCase (e.g., `UserProfile`, `AuthState`)
- **Variables:** camelCase (e.g., `userName`, `totalCount`)
- **Functions:** camelCase (e.g., `calculateTotal`, `getUserById`)
- **Constants:** UPPERCASE_SNAKE_CASE (e.g., `API_BASE_URL`, `MAX_RETRY_COUNT`)
- **Environment variables:** UPPERCASE_SNAKE_CASE (e.g., `NEXT_PUBLIC_API_URL`)
- **Custom hooks:** camelCase with use- prefix (e.g., `useAuth`, `useDebounce`)
- **Event handlers:** camelCase with handle- prefix (e.g., `handleClick`, `handleSubmit`)
- **Boolean variables:** camelCase with auxiliary verb (e.g., `isLoading`, `hasError`, `canEdit`)
- **Private functions:** camelCase with underscore prefix (e.g., `_helperFunction`)

### Specific Patterns
- **Props interfaces:** ComponentName + Props (e.g., `ButtonProps`)
- **State types:** Feature + State (e.g., `AuthState`, `UserState`)
- **Query keys:** Nested arrays (e.g., `['users', 'list', filters]`)
- **Zustand stores:** use + Feature + Store (e.g., `useAuthStore`, `useCartStore`)
- **Context:** Feature + Context (e.g., `ThemeContext`, `AuthContext`)
- **Enum alternatives:** Const objects with 'as const' assertion

---

## TypeScript Best Practices

### Configuration
- Enable all strict mode options in tsconfig.json
- Enable noUncheckedIndexedAccess to catch undefined array access
- Enable noImplicitReturns for explicit return statements
- Enable noFallthroughCasesInSwitch for switch safety
- Use moduleResolution: bundler for modern module resolution

### Type Definitions
- Prefer interfaces over types for object shapes (better error messages)
- Use type for unions, intersections, and mapped types
- Avoid enums entirely, use const objects with type extraction
- Export types alongside implementation when public API
- Use branded types for nominal typing when needed
- Leverage template literal types for string unions

### Type Safety Patterns
- Never use 'any' type, use 'unknown' for truly unknown values
- Avoid type assertions (as, !) unless absolutely necessary
- Use type guards for runtime type checking
- Implement discriminated unions for complex state machines
- Use generic constraints to enforce type relationships
- Apply utility types (Partial, Required, Pick, Omit, Record) liberally

### Advanced Patterns
- Use mapped types for transforming existing types
- Implement conditional types for type-level logic
- Leverage infer keyword for type extraction
- Create custom utility types for domain-specific needs
- Use const assertions for literal type inference
- Implement function overloads for better type inference

---

## Component Architecture (Atomic Design)

### Design System Hierarchy

**Atoms (Basic Building Blocks):**
- Single-purpose, highly reusable components
- No business logic, only presentation
- Examples: Button, Input, Label, Icon, Badge
- Should be fully controlled components
- Accept all native HTML props via rest spread

**Molecules (Simple Combinations):**
- Combine 2-3 atoms into functional units
- Minimal business logic, mostly composition
- Examples: FormField (Label + Input + Error), SearchBox (Input + Button)
- Accept composition via children or render props
- Handle internal coordination between atoms

**Organisms (Complex Components):**
- Combine molecules and atoms into feature sections
- Contains business logic and state management
- Examples: Header, Sidebar, UserProfileCard, DataTable
- May fetch data or connect to global state
- Encapsulate feature-specific behavior

**Templates (Page Layouts):**
- Combine organisms into page structures
- Define content layout and spacing
- Examples: DashboardLayout, AuthLayout, MarketingLayout
- No business logic, only structural composition
- Accept children for content areas

**Pages (Route Components):**
- Actual route handlers in Next.js app directory
- Fetch data and pass to templates
- Handle page-level concerns (metadata, loading, errors)
- Thin layer that composes templates with data

### Component Composition Principles
- Components should be open for extension via children
- Use render props for customizable behavior
- Prefer composition over configuration
- Keep prop APIs minimal and focused
- Use compound components for related UI elements
- Avoid prop drilling beyond 2 levels (use context instead)

### Component Responsibility Guidelines
- Each component should do one thing well
- Extract reusable logic into custom hooks
- Keep components pure when possible (same props = same output)
- Separate concerns: presentation vs logic vs data fetching
- Avoid mixing server and client component concerns

---

## File Structure Standards

### Project Organization
```
src/
├── app/                          # Next.js App Router
│   ├── (auth)/                  # Route groups for layout sharing
│   ├── (dashboard)/
│   ├── api/                     # API routes
│   ├── layout.tsx               # Root layout
│   ├── page.tsx                 # Home page
│   ├── error.tsx                # Error boundary
│   ├── loading.tsx              # Loading UI
│   └── not-found.tsx            # 404 page
│
├── components/
│   ├── atoms/                   # Basic components
│   ├── molecules/               # Composite components
│   ├── organisms/               # Complex components
│   ├── templates/               # Page layouts
│   └── ui/                      # Shadcn UI components
│
├── hooks/                       # Custom React hooks
├── lib/                         # Utility functions
├── stores/                      # State management (Zustand)
├── actions/                     # Server actions
├── services/                    # Business logic layer
├── types/                       # TypeScript type definitions
├── config/                      # Configuration files
├── constants/                   # Application constants
├── styles/                      # Global styles
└── __tests__/                   # Test utilities and mocks
```

### Component File Structure
Within each component directory:
```
component-name/
├── component-name.tsx           # Main component
├── component-name.test.tsx      # Tests
├── component-name.stories.tsx   # Storybook stories (optional)
├── sub-component.tsx            # Tightly coupled sub-components
├── hooks.ts                     # Component-specific hooks
├── utils.ts                     # Component-specific utilities
└── index.ts                     # Public API exports
```

### File Content Order
Every component file should follow this structure:
1. Imports (external → internal → types)
2. Type definitions and interfaces
3. Constants (component-specific)
4. Helper functions (small, pure functions)
5. Main component function
6. Sub-components (if tightly coupled)
7. Display name assignment
8. Exports (named exports preferred)

---

## React Patterns & Best Practices

### Server vs Client Components

**Default to Server Components:**
- Fetch data directly in server components
- No need for useEffect or loading states
- Better performance (less JavaScript to browser)
- Automatic request deduplication
- Can access backend resources directly

**Use Client Components only for:**
- Event listeners (onClick, onChange, onSubmit)
- Browser APIs (localStorage, window, document)
- React hooks (useState, useEffect, useContext)
- Third-party libraries requiring browser environment
- Interactive animations and transitions

**Best Practices:**
- Keep client components small and focused
- Pass data from server to client components via props
- Use 'use client' directive at top of file
- Don't import server components into client components
- Create client wrappers when necessary

### Custom Hooks Patterns

**When to create custom hooks:**
- Reusable stateful logic across components
- Complex state management that clutters components
- Side effects that need to be shared
- Integration with external libraries
- Browser API abstractions

**Hook design principles:**
- Single responsibility per hook
- Return tuple or object (prefer object for multiple values)
- Use TypeScript generics for flexibility
- Document parameters and return values with JSDoc
- Handle cleanup in useEffect return function
- Make hooks composable (hooks can use other hooks)

**Common hook patterns:**
- Data fetching hooks (useUser, useProducts)
- Form management hooks (useForm, useValidation)
- UI state hooks (useToggle, useModal, useDisclosure)
- Browser API hooks (useLocalStorage, useMediaQuery, useDebounce)
- Animation hooks (useAnimation, useScrollPosition)

### Component Patterns

**Controlled vs Uncontrolled:**
- Prefer controlled components for forms
- Use uncontrolled for performance-critical inputs
- Always provide onChange when using value prop
- Use defaultValue for uncontrolled components

**Composition Patterns:**
- Use children prop for flexible content
- Implement compound components for related UI
- Use render props for customizable behavior
- Apply slots pattern for multiple insertion points

**Error Boundaries:**
- Implement error.tsx in app directory for route-level boundaries
- Create reusable ErrorBoundary component for component-level
- Always provide fallback UI
- Log errors to monitoring service
- Allow retry functionality where appropriate

---

## Performance Optimization

### React Performance

**Memoization Strategy:**
- Use React.memo for expensive pure components
- Apply useMemo for expensive computations only
- Use useCallback to stabilize function references
- Don't over-optimize - measure first
- Memoize when passing callbacks to optimized children

**When to use React.memo:**
- Component renders frequently with same props
- Component has expensive rendering logic
- Component is in a list with many items
- Parent re-renders often but props rarely change

**When to use useMemo:**
- Computationally expensive calculations
- Creating objects/arrays passed as props
- Filtering or transforming large datasets
- Creating derived state from props

**When to use useCallback:**
- Functions passed to memoized child components
- Functions used as dependencies in other hooks
- Event handlers passed to optimized children
- Callbacks in dependency arrays

### Next.js Optimization

**Image Optimization:**
- Always use next/image for all images
- Specify width and height to prevent layout shift
- Use priority prop for above-fold images
- Implement lazy loading for below-fold images
- Use appropriate formats (WebP, AVIF)
- Optimize quality setting (75-80 is usually sufficient)

**Code Splitting:**
- Use dynamic imports for heavy components
- Implement route-based code splitting
- Split vendor bundles strategically
- Lazy load modals, dialogs, and drawer content
- Load third-party scripts asynchronously

**Data Fetching Optimization:**
- Parallel data fetching where possible
- Use React Suspense for progressive loading
- Implement proper caching strategies
- Prefetch data on link hover
- Use ISR for semi-static content
- Implement pagination for large datasets

**Bundle Size Optimization:**
- Use bundle analyzer to identify large dependencies
- Import only needed functions from libraries
- Replace heavy libraries with lighter alternatives
- Remove unused CSS with PurgeCSS
- Enable tree shaking
- Minimize polyfills for modern browsers

### Rendering Strategies

**Static Generation (SSG):**
- Use for content that doesn't change often
- Build pages at build time
- Best performance and SEO
- Can revalidate with ISR

**Server-Side Rendering (SSR):**
- Use for personalized content
- Renders on each request
- Good for dynamic data
- Supports streaming

**Incremental Static Regeneration (ISR):**
- Best of both SSG and SSR
- Static pages that update periodically
- Use revalidate option
- Ideal for content that changes occasionally

**Client-Side Rendering (CSR):**
- Use sparingly, only when necessary
- Good for highly interactive features
- Implement proper loading states
- Consider SEO implications

---

## Error Handling & Validation

### Error Handling Patterns

**Early Returns Strategy:**
- Handle error conditions at function start
- Return early for invalid inputs
- Avoid deeply nested if statements
- Place happy path last for readability

**Guard Clauses:**
- Validate preconditions immediately
- Check for null/undefined early
- Verify permissions upfront
- Fail fast principle

**Error Boundaries:**
- Implement at route level (error.tsx)
- Create reusable component-level boundaries
- Provide meaningful fallback UI
- Log errors to monitoring service
- Allow graceful recovery where possible

**Server Actions Error Handling:**
- Use next-safe-action for type-safe actions
- Return error objects, don't throw for expected errors
- Validate input with Zod schemas
- Provide user-friendly error messages
- Log unexpected errors server-side

### Validation Strategy

**Client-Side Validation:**
- Use Zod for schema definitions
- Integrate with React Hook Form
- Provide immediate feedback
- Show field-level errors
- Disable submit on validation errors

**Server-Side Validation:**
- Always validate on server (never trust client)
- Use same Zod schemas for consistency
- Return detailed validation errors
- Sanitize all user inputs
- Log validation failures for monitoring

**Validation Patterns:**
- Define schemas in separate files
- Create reusable validation utilities
- Compose schemas for complex forms
- Use custom validators for business rules
- Transform data during validation

---

## State Management

### State Classification

**Local State (useState/useReducer):**
- UI state (toggles, inputs, modals)
- Form state (managed by React Hook Form)
- Component-specific state
- Temporary state that doesn't need persistence

**Global Client State (Zustand):**
- Authentication state
- Theme preferences
- Shopping cart
- User settings
- UI state shared across routes

**Server State (TanStack Query):**
- Data from API
- Cached responses
- Paginated data
- Real-time data
- Any data that originates from server

**URL State (nuqs):**
- Search parameters
- Filters and sorting
- Pagination state
- Tab selections
- Any state that should be shareable via URL

### Zustand Best Practices

**Store Organization:**
- Create separate stores by domain
- Keep stores focused and minimal
- Use slices for large stores
- Avoid deeply nested state
- Normalize data structures

**Store Patterns:**
- Use selectors to prevent unnecessary re-renders
- Implement middleware for persistence
- Add devtools for debugging
- Create typed hooks for store access
- Use immer middleware for immutable updates

### TanStack Query Best Practices

**Query Configuration:**
- Use query keys consistently
- Implement proper stale time
- Configure cache time appropriately
- Enable refetch on window focus selectively
- Use placeholderData for better UX

**Mutation Patterns:**
- Invalidate related queries after mutations
- Use optimistic updates for better UX
- Handle rollback on mutation failure
- Provide loading states during mutations
- Show success/error notifications

---

## Form Handling

### React Hook Form Integration

**Form Setup:**
- Use useForm hook with Zod resolver
- Define validation schema with Zod
- Register fields with proper validation
- Handle submission with async functions
- Provide loading states during submission

**Field Registration:**
- Use register for simple inputs
- Use Controller for complex components
- Apply proper validation rules
- Show field-level errors
- Disable fields during submission

**Form Patterns:**
- Extract reusable form components
- Implement proper error handling
- Show validation errors clearly
- Provide success feedback
- Handle file uploads appropriately

### Validation with Zod

**Schema Definition:**
- Define schemas close to usage
- Create reusable sub-schemas
- Use transformers for data normalization
- Implement custom validators
- Add helpful error messages

**Advanced Patterns:**
- Conditional validation with refine
- Cross-field validation
- Async validation for uniqueness checks
- Dynamic schemas based on conditions
- Schema composition and extension

---

## Testing Strategy

### Testing Philosophy
- Write tests that verify user behavior, not implementation
- Test user interactions, not internal state
- Prioritize integration tests over unit tests
- Write tests that give confidence in deployments
- Keep tests maintainable and readable

### Unit Testing

**What to test:**
- Utility functions and helpers
- Custom hooks logic
- Data transformations
- Validation functions
- Business logic calculations

**Tools and setup:**
- Jest for test runner
- React Testing Library for component testing
- Mock Service Worker (MSW) for API mocking
- Testing Library User Event for interactions

**Best practices:**
- Follow AAA pattern (Arrange, Act, Assert)
- Test one behavior per test
- Use descriptive test names
- Avoid testing implementation details
- Mock external dependencies
- Clean up after each test

### Integration Testing

**What to test:**
- User workflows (login, checkout, etc.)
- Component interactions
- Form submissions
- Navigation flows
- Data fetching and display

**Patterns:**
- Test from user's perspective
- Use realistic test data
- Test happy paths and error cases
- Verify loading and error states
- Test accessibility features

### E2E Testing with Playwright

**What to test:**
- Critical user journeys
- Cross-browser compatibility
- Mobile responsiveness
- Performance metrics
- Visual regression

**Best practices:**
- Keep tests independent
- Use page object model
- Implement proper waits
- Test in parallel
- Run in CI/CD pipeline

### Test Organization

**File structure:**
- Colocate tests with components
- Create test utilities in __tests__ directory
- Share fixtures and mocks
- Organize by feature/domain

**Coverage goals:**
- Aim for 70-80% coverage
- 100% for critical paths
- Don't chase 100% everywhere
- Focus on meaningful tests

---

## JSDoc Documentation

### When to Write JSDoc

**Always document:**
- Public APIs and exported functions
- Complex algorithms or business logic
- Functions with non-obvious behavior
- Custom hooks
- Utility functions
- Type definitions with special meaning

**Skip documentation for:**
- Self-explanatory code
- Private internal functions
- Generated code
- Obvious getters/setters
- Simple components with clear props

### JSDoc Format Standards

**Function documentation template:**
```typescript
/**
 * Brief one-line description of what the function does
 * 
 * Optional longer description with additional context,
 * explaining the why and how, not just the what.
 * 
 * @param paramName - Description of parameter
 * @param optionalParam - Description with default behavior
 * @returns Description of return value
 * @throws {ErrorType} When error occurs
 * 
 * @example
 * ```typescript
 * // Example usage showing typical case
 * const result = functionName(arg1, arg2)
 * ```
 * 
 * @example
 * ```typescript
 * // Example showing edge case
 * const result = functionName(null, undefined)
 * ```
 * 
 * @see RelatedFunction - For related functionality
 * @deprecated Use newFunction instead since v2.0
 */
```

**Component documentation template:**
```typescript
/**
 * ComponentName - Brief description of component purpose
 * 
 * Longer description explaining when to use this component,
 * any important behavioral notes, or design decisions.
 * 
 * @example
 * ```tsx
 * <ComponentName
 *   requiredProp="value"
 *   optionalProp={123}
 * />
 * ```
 */
```

**Custom hook documentation template:**
```typescript
/**
 * Custom hook description explaining what problem it solves
 * 
 * @param param1 - Description of first parameter
 * @returns Object containing { value, setValue, isValid }
 * 
 * @example
 * ```tsx
 * function MyComponent() {
 *   const { value, setValue, isValid } = useCustomHook('initial')
 *   return <div>{value}</div>
 * }
 * ```
 */
```

### Documentation Best Practices

**Content guidelines:**
- Write in present tense
- Be concise but complete
- Explain why, not just what
- Include edge cases in examples
- Document gotchas and limitations
- Link to related documentation

**Parameter documentation:**
- Describe purpose and expected values
- Note any constraints or validation
- Specify optional with default values
- Document object shapes inline
- Use @param {Type} syntax for types

**Return value documentation:**
- Describe what is returned
- Document all possible return types
- Explain null/undefined returns
- Document async return promises
- Note side effects if any

**Example guidelines:**
- Show typical usage first
- Include edge cases
- Use realistic data
- Keep examples short
- Show multiple patterns when relevant

---

## Accessibility (a11y)

### Core Principles

**Semantic HTML:**
- Use appropriate HTML elements for their purpose
- Prefer button over div for clickable elements
- Use form elements inside form tags
- Implement proper heading hierarchy (h1-h6)
- Use nav, main, article, aside appropriately

**Keyboard Navigation:**
- All interactive elements must be keyboard accessible
- Implement logical tab order
- Provide visible focus indicators
- Support standard keyboard shortcuts
- Trap focus in modals and dialogs

**Screen Reader Support:**
- Add descriptive ARIA labels
- Use aria-describedby for additional context
- Implement aria-live regions for dynamic content
- Use aria-hidden to hide decorative elements
- Provide alternative text for images

### ARIA Best Practices

**When to use ARIA:**
- When semantic HTML is insufficient
- For custom interactive widgets
- To provide additional context
- For dynamic content updates
- To indicate current state

**ARIA patterns:**
- Use role attribute for custom widgets
- Implement aria-expanded for collapsible content
- Add aria-selected for tab interfaces
- Use aria-checked for custom checkboxes
- Implement aria-pressed for toggle buttons

### Color and Contrast

**WCAG Guidelines:**
- Maintain 4.5:1 contrast for normal text
- Maintain 3:1 contrast for large text
- Ensure 3:1 contrast for UI components
- Don't rely on color alone to convey information
- Provide text labels in addition to color coding

### Testing Accessibility

**Automated testing:**
- Use jest-axe for unit tests
- Run Lighthouse accessibility audits
- Use eslint-plugin-jsx-a11y
- Test with axe DevTools browser extension

**Manual testing:**
- Navigate entire app with keyboard only
- Test with screen readers (NVDA, JAWS, VoiceOver)
- Verify zoom up to 200%
- Test with reduced motion preferences
- Validate form errors are announced

---

## Security Best Practices

### Input Validation and Sanitization

**Never trust user input:**
- Validate all inputs on server-side
- Sanitize data before storage
- Use parameterized queries for database
- Validate file uploads (type, size, content)
- Implement rate limiting on endpoints

**XSS Prevention:**
- Never use dangerouslySetInnerHTML with user content
- Sanitize HTML with DOMPurify if necessary
- Use CSP headers to restrict inline scripts
- Encode output based on context
- Validate and sanitize all user-generated content

### Authentication and Authorization

**Authentication best practices:**
- Use established libraries (NextAuth, Auth0)
- Implement secure password hashing (bcrypt, argon2)
- Use HTTP-only cookies for session tokens
- Implement CSRF protection
- Support MFA for sensitive accounts

**Authorization patterns:**
- Verify permissions on every request
- Implement role-based access control
- Use middleware for route protection
- Check authorization server-side always
- Follow principle of least privilege

### Data Protection

**Sensitive data handling:**
- Store secrets in environment variables
- Never commit secrets to version control
- Use .env.local for local development
- Rotate API keys periodically
- Encrypt sensitive data at rest

**API Security:**
- Use HTTPS everywhere
- Implement request signing where appropriate
- Rate limit all public endpoints
- Validate content-type headers
- Implement proper CORS policies

### Dependency Security

**Dependency management:**
- Audit dependencies regularly (npm audit)
- Keep dependencies updated
- Review dependency licenses
- Minimize dependency count
- Use lock files for reproducible builds

**Supply chain security:**
- Verify package signatures
- Use tools like Snyk or Dependabot
- Review dependency changes before updating
- Pin critical dependencies to specific versions
- Monitor for security advisories

---

## Final Checklist

### Before Committing
- [ ] TypeScript compiles without errors
- [ ] All tests pass
- [ ] No console.logs or debugger statements
- [ ] Code follows naming conventions
- [ ] JSDoc added for public APIs
- [ ] Accessibility requirements met
- [ ] Error handling implemented
- [ ] Loading states provided
- [ ] Responsive design tested
- [ ] Images optimized

### Before Deployment
- [ ] Environment variables configured
- [ ] Build succeeds
- [ ] Lighthouse scores acceptable
- [ ] Security audit passed
- [ ] Performance metrics within targets
- [ ] SEO metadata complete
- [ ] Analytics integrated
- [ ] Error monitoring setup
- [ ] Backup strategy in place
- [ ] Rollback plan documented